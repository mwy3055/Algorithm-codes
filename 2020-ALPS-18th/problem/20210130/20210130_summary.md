# 1월 31일 스터디 요약


## [내리막 길](https://www.acmicpc.net/problem/1520) 



*   일반적으로는 2차원 맵에서 오른쪽/아래로만 움직이지만, 이렇게 상하좌우로 움직이는 경우에는 더 헷갈릴 수 있다.
*   하지만 차분히 생각해 보자. 한번 방문한 칸에는 두 번 다시 방문할 수 없다.
    *   지금까지 지나온 길의 값은 현재 내 위치보다 모두 크기 때문에 애초에 갈 수조차 없다.
*   <span style="text-decoration:underline;">재귀 DP를 통해</span> 네 방향을 고려하여 탐색을 해나가면 된다. 탐색에 쓰는 자료구조는 2차원 배열 뿐 


## [동전 바꿔주기](https://www.acmicpc.net/problem/2624) 



*   각 금액의 동전의 개수가 다르게 주어져서 DP 배열의 누적을 구현하는데 좀 까다로웠던 문제
*   오름차순으로 정렬을 해주어야만 DP를 수행할 수 있다!   
*   DP(i, j) -> i 번째 동전을 사용해서 j 원 을 만드는 경우의 수 
    *   DP 정의에 동전의 개수를 포함하지 않아도 된다. 포함한다고 해도 매우 복잡해질 것. (금액이 달라도 동전은 동전)
*   각 금액의 동전의 개수의 대한 판단은 입력받은 개수만큼 for loop를 통해 

    dp[i][j] 에 dp[i-1][j-k*금액] 씩 더해주면 된다. 

*   다음 동전의 금액에 도달하지 못하는 구간을 빠짐 없이 채워주는 것이 동전 문제의 중요 포인트라고 할 수 있겠다. 


## [가장 긴 증가하는 부분 수열 4 ](https://www.acmicpc.net/problem/14002)



*   LIS의 결과를 추적하는 문제
*   알고리즘을 정확히 이해하고 있다면 어렵지 않을 것이다. 문제가 어려웠다면 LIS를 정확히 이해하는 계기로 삼아 보자.
*   nlogn으로 LIS를 구현하는 방법도 알아두자.
*   <span style="text-decoration:underline;">이 [문제는 N^2로 풀 수 없다.](https://www.acmicpc.net/problem/14003)</span>  


## [아우으 우아으이야!! ](https://www.acmicpc.net/problem/15922)



*   정렬을 이미 해준 문제 
*   벡터에 넣어서 하나씩 꺼내서 기존의 선분과 다음 선분의 관계를 설정해주는 것이 핵심인 문제. 전체를 한꺼번에 보려하면 풀지 못 한다.
*   앞선 선분과 다음 선분의 관계는 3가지의 관계 뿐이다. 포함하거나 , 겹치거나, 만나지 않거나 
*   세가지의 케이스를 나누어 선분의 길이의 합을 누적해서 더해주면 된다. 
*   포함하면 continue, 겹치면 겹친만큼 빼주고, 만나지 않으면 pass 
*   emplace_back()를 사용하면 pair를 사용하지 않아도 알아서 pair로 묶어서 넣어준다 자주 쓰도록 하자.


## [나무 재테크 ](https://www.acmicpc.net/problem/16235)



*   주어진 대로 구현하면 되는 문제
*   조건만 정확히 파악하면 이미 다 푼 것이다. 문제에서 무엇을 요구하고 있는지, 요구를 충족하기 위해 어떤 데이터가 필요한지 고민해 보자.
    *   <span style="text-decoration:underline;">모든 개발 프로세스가 이런 방식으로 진행된다.</span>
*   구조체와 클래스 등을 적극적으로 사용하자
*   알고리즘 문제를 <span style="text-decoration:underline;">푼다</span>라기 보단 하나의 게임을, 하나의 어플을 만든다는 생각으로 차근차근 <span style="text-decoration:underline;">구현</span>해주면 된다.
