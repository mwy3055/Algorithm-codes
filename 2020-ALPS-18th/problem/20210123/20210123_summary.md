# 1월 24일 스터디 요약

## [치즈](https://www.acmicpc.net/problem/2638) 



*   _테두리 칸에는 치즈가 들어갈 수 없다_라는 조건을 활용해야한다
    *   테두리에는 무조건 공기이기 때문에 (0,0)과 같은 좌표에서 BFS 탐색을 시작해도 예외상황이 존재하지 않는다. 사실 문장이 조금 모호하긴 하다.
*   치즈 외부에서부터 탐색을 시작하여 공기와 만나면 계속 이동하고(queue에 담아주고) 치즈와 만나면 이동을 하지 않고 방문 횟수만 증가시켜준다(queue에 담지 않고, check++)
*   그러면 이제 외부 공기와 2번 이상 만나는 치즈를 녹여주기만 하면 된다. 그리고 이젠 치즈가 전부 녹을 때 까지 반복 (cnt++)
*   포인트: 치즈가 아닌 공기를 기준으로 생각하자! 치즈가 녹으려면 공기의 조건이 필요하기 때문이다.
*   치즈 기준, 외부 공기 내부 공기 이런 식으로 구분하여 풀 수 도 있긴 한데… 굳이?

    [https://yabmoons.tistory.com/342](https://yabmoons.tistory.com/342)



## [선발 명단](https://www.acmicpc.net/problem/3980) 



*   뭐가 제일 큰지 모르겠다면 다 해보면 된다.
    *   방법은 순열 또는 그냥 브루트포스(DFS)를 사용하여 한 선수를 한 선수를 선택하여 다음 재귀로 들어가서(재귀 종료 시에 선수 선택을 초기화 해주는 것 필요!) 모든 선수를 다 골랐을 때의 점수가 기존의 점수보다 작을 경우 갱신
*   DP로도 할 수 있다. 
    *   현재까지 사용한 선수의 집합과 현재까지 배치된 포지션의 집합 2개를 비트마스크로 사용하면 된다. 다음의 함수를 정의하자.
    *   solve(player_bit, pos_bit): 현재까지 배치된 선수의 집합이 player_bit이고, 현재까지 배치된 포지션의 집합이 pos_bit일 때, 나머지 선수를 배치하여 얻을 수 있는 능력치의 최댓값
    *   이제 선택되지 않은 선수 **<span style="text-decoration:underline;">한 명</span>**만 배치해 보면 된다. 나머지는 다른 재귀에서 계산될 것이다.
    *   하지만 선수를 배치하다 보면 더 이상 선수를 배치할 수 있는 방법이 없는 경우가 생긴다. 이 경우에는 더이상 배치가 불가능함을 표현하기 위해 매우 작은 값(음수)를 반환해야 한다.


## [Count Circle Groups ](https://www.acmicpc.net/problem/10216)



*   간선 대신 정점이 주어진 그래프 문제. 정점으로부터 간선(연결되어 있는지)을 직접 계산해야 한다. 이 문제의 경우, 두 진영 사이의 거리가 R 이하라면 연결되어 있는 것으로 간주한다.
*   N이 꽤 크고, 연결 여부를 판단하기가 어렵지 않으므로(거리 계산!) N*N 배열을 만들지 않고 두 진영이 연결되어 있는지 판단하는 함수를 정의해도 된다.
*   그 다음부터는 전형적인 BFS/DFS 문제. 모든 진영에 대해 아직 탐색되지 않은 진영으로부터 탐색을 실시하면 된다.
*   <span style="text-decoration:underline;">정점으로부터 간선을 직접 만드는 데</span>에 의의가 있는 문제.


## [4연산 ](https://www.acmicpc.net/problem/14395)



*   뭔가 범위가 넓어 보이는 BFS 문제
*   수의 범위가 최대 10억이라서 visit 배열을 만들 수 없다(메모리 초과)
*   하지만 이 문제에서 탐색하는 수의 개수가 적기 때문에(이유는 하술) set을 쓸 수 있다.
*   정답 문자열을 만드는 방법
    *   BFS 할 때 큐에 문자열을 같이 넣는다. 일반적으로 권장하는 방법은 아니지만 뭐 사용할 수는 있다.
    *   지금까지의 선택을 추적하는 배열을 만든다. 예를 들어 (도착: 9, 출발: 3) 등의 정보를 저장하는 것이다. 도착점과 출발점의 값만 알면 사용한 연산(위에서는 *)을 알 수 있기 때문이다. 다만 배열을 사용할 수 없기 때문에 map 자료구조를 사용해야 한다. (파이썬은 dict)
    *   이처럼 **<span style="text-decoration:underline;">BFS에서 최적 경로를 찾는 문제</span>**가 많이 나오므로 충분히 연습하자.
*   탐색하는 수의 개수가 적은 이유
    *   '+' 연산은 s를 2*s로 만든다. 따라서 + 연산을 계속 사용하면 s*2^{k}(k는 자연수) 꼴의 값을 얻을 수 있다. 그런데 s=2라고 하더라도 k는 최대 30밖에 안 된다. 따라서 + 연산으로 만들어지는 값의 개수는 매우 적다.
    *   '-' 연산은 s를 0으로 만든다. 그런데 t가 0이 아니므로 - 연산은 안 써도 된다.
    *   '*' 연산은 s를 s^{2}로 만든다. + 연산과 마찬가지로 s=2라고 해도 k는 최대 30밖에 안 된다.
    *   '/' 연산은 s를 1로 만든다. 따라서 모든 탐색 중 단 한 번만 사용하게 된다.
    *   이처럼 연산의 특성을 살펴보면 만들어지는 값의 개수가 매우 적음을 알 수 있다. 범위는 넓지만 실제로 사용되는 값은 매우 적은 것이다.


## [아기 상어 ](https://www.acmicpc.net/problem/16236)



*   구현!
*   공간의 크기가 매우 작으므로 주어진 기능을 정확히 구현하는 데에 집중하자. 효율성은 조금 포기해도 된다.
*   오늘 문제 중 가장 [코딩테스트다운](https://www.acmicpc.net/workbook/view/1152) 문제…! (이런 문제를 잘 풀어내야 한다ㅠㅠ)
*   삼성 SW 역량테스트 기출 문제에 비슷한 문제가 많이 수록되어있다! 
*   귀찮다고 거르면 내가 걸러진다
