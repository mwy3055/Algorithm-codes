# 1월 9일 스터디 정리
# 문제


## [후보 추천하기](https://www.acmicpc.net/problem/1713) 



*   뭔가 조건이 많지만 주어진 대로 구현하면 되는 문제
*   한번에 맞추는 연습을 하자.
*   추천: 사진틀을 구현한다. 가장 오래된 사진을 찾는다던가 하는 메소드를 전부 구현하면 좋다.


## [미로 탈출](https://www.acmicpc.net/problem/14923) 



*   각 칸의 가중치가 다른 BFS 탐색 
*   방문 체크 배열을 3차원배열로 만들어주어야 한다. visit[x][y][k] (k: 벽을 부술 수 있는 횟수)
*   벽을 부수고 그 칸을 방문한 것과 벽을 아직 부수지 않고 그 칸을 방문한 것은 아예 다른 개념이다.
*   위에 개념만 알고 있으면 남은건 평소에 해왔던 평범한 BFS 구현 


## [1, 2, 3 더하기 7](https://www.acmicpc.net/problem/15992) 



*   숫자가 커질 수 있으므로 dp 배열의 type을 long long으로 해주는 것을 잊지 말자
*   아니면 덧셈할때마다 MOD 계산을 다 해줘야 된다.
*   dp(i,j,k)  ->첫번째로 오는 수 가 k일때 1,2,3의 합으로 정수 i을 j개의 수로 만드는 경우의 수  (ex i = 4, j = 3 k=2 -> 4 = 2+1+1) 
*   조금 더 최적화하면 인자 2개만으로 DP식을 세울 수 있다.
*   dp[n][m]: 정수 n을 1, 2, 3 m개만을 이용하여 만드는 경우의 수


## [만족도 점수](https://www.acmicpc.net/problem/16501) 



*   팀을 만들 수 있는 모든 경우를 검사하면 된다. 이때 테니스 코트 하나만 봐도 된다. _왜?_
*   점수 계산보다 정답 출력이 더 어려울 수 있다.
    *   문제에서 소수 둘째 자리까지<span style="text-decoration:underline;">만</span> 이야기하고 있는 이유는?
    *   부동소수점 오차를 어떻게 피할 수 있을까? 
    *   1) 나누기를 해준 만큼 다시 곱해주거나, 2)나누기를 안하는 방법이 있다.
*   모든 페어를 시합을 시키는 방법은 배열에 넣어 전체 인원중 4명을 시합시키는 **next_permutation()**함수를 이용하면 된다. 


## [CPU 벤치마킹](https://www.acmicpc.net/problem/20312) 



*   N을 보아하니 2차원 DP로 해결할 수 없는 문제 (애초에 2차원 DP는 O(N^3)이라서 맞을 수가 없다)
*   1차원 DP로 해결해야 한다.
*   힌트: dp[i]와 dp[i-1]과의 관계가 잘 보이지 않는다면, 표에 숫자 대신 문자(식)를 적어놓고 생각해 보자. 숫자로 표를 채우는 것 보다 관계가 더 명확하게 보일 것이다.
