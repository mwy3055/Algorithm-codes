# 1월 2일 스터디 요약


# 문제


## [로봇 시뮬레이션](https://www.acmicpc.net/problem/2174) 



*   로봇 클래스를 정의해 보자. 
    *   필드: 위치(x, y), 이동 방향
    *   메소드: 좌/우 회전, 앞으로 전진
*   방향을 숫자로 표현하면 dx, dy 등을 사용하여 코드 반복을 줄일 수 있다. map 탐색에서 자주 쓰는 방법이니 알아 두자.
*   로봇을 이동할 때, 꼬리가 남지 않도록 주의하자.
*   성실하게 구현해 나가자 하나라도 더 맞추는게 코테에서는 최선
*   틀리지 않고 한번에 정확하게 푸는 연습(예외처리, 요구사항) 


## [알약](https://www.acmicpc.net/problem/4811) 



*   중복순열 아니다! H가 맨 처음에 올 수 없기 때문이다,
*   대신 DP로 문제를 해결할 수 있다.
*   dp(i, j): 한 조각이 i개, 반쪽 조각이 j개 있을 때 문자열을 만드는 경우의 수 
*   한 조각을 먹을 때의 경우의 수는 dp(i-1, j+1), 반쪽 조각을 먹을 때의 경우의 수는 dp(i, j-1)이므로 둘을 합하면 된다. 구현은 재귀/반복문 아무거나 써도 된다.
*   예제가 친절했다(출력 범위 고려)


## [스위치와 램프](https://www.acmicpc.net/problem/16960) 



*   문제를 풀 때는 모든 스위치를 켜놓은 다음에 한개씩 꺼 보면서 n-1개로 모든 램프를 켤 수 있을까? 생각하는게 쉽다. ‘해당 램프를 켜는 스위치의 개수’를 램프 배열에 저장하여 그 원소의 값이 하나라도 0이하로 바뀌면 모든 램프를 켤 수 없는 것! 
*   스위치와 램프의 연결관계를 이차원 배열에 저장 해놓으면 이진탐색을 굳이 하지 않아도 된다.
*   써도 된다. binary_search() 함수 이용 


## [디저트](https://www.acmicpc.net/problem/17953) 



*   부분 문제를 여러 가지 방법으로 정의할 수 있다. 정의하는 방법에 따라 푸는 방법도 다르다.
    *   dp(i, j, same): i번째 날에 j번 디저트를 먹었을 때 얻을 수 있는 만족감의 최댓값. 이때 전날과 같은 디저트를 먹었다면 same은 1, 아니면 0이다.
        *   각 디저트 k에 대해 dp(i, j, same) = max(dp(i+1, k, j==k)) + (i번째 날에 j번 디저트를 먹었을 때의 만족도)이다.
    *   dp2(i, j): i번째 날에 j번 디저트를 먹었을 때 얻을 수 있는 만족감의 최댓값. 


## [니가 싫어](https://www.acmicpc.net/problem/20440)



*   숫자가 너무 크다! 무려 21억!
*   <span style="text-decoration:underline;">좌표 압축</span>을 이용하여 수의 범위를 줄일 수 있다. 값 대신 상대적인 순서(오름차순 등)를 사용하는 것이다. 이름은 몰라도 개념만 기억하고 있자.
    *   “4는 2번째로 작은 수이다” → 4를 2로 매핑
*   부분합?
    *   _여기에 풀이를 적어 주세요_
*   [우선순위 큐](https://thinking-face.tistory.com/entry/20440-%F0%9F%8E%B5%EB%8B%88%EA%B0%80-%EC%8B%AB%EC%96%B4-%EC%8B%AB%EC%96%B4-%EB%84%88%EB%AC%B4-%EC%8B%AB%EC%96%B4-%EC%8B%AB%EC%96%B4-%EC%98%A4%EC%A7%80-%EB%A7%88-%EB%82%B4%EA%B2%8C-%EC%B0%9D%EC%A9%8D%EB%8C%80%EC%A7%80%EB%A7%88%F0%9F%8E%B5-1)를 이용해서 풀 수도 있다.
